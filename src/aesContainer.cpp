//Our headers
#include <reference.hpp>
#include <aesContainer.hpp>

//STD C++ Library
#include <cstring>

using Kyrys::AesContainer;


//Constructors
AesContainer::AesContainer(unsigned char* key, const std::string& plain_input, unsigned int version) : m_version(version), m_data(plain_input){
	//copying of key inside container
	memcpy(m_key, key, 16);

	//Initializing of aes context by uKey
	if(mbedtls_aes_setkey_enc( &m_aes, m_key, m_version) == MBEDTLS_ERR_AES_INVALID_KEY_LENGTH){
		std::cout << "AesContainer::Parametric_Constructor: key has wrong length" << std::endl;
	}

	//Initializing of iv
	initializeIV();

	m_paddingLength = (unsigned int) m_data.length() % m_version;
	if(m_paddingLength != 0)
		m_output_length = m_data.length() - m_paddingLength + m_version;
}


//Getters
unsigned int AesContainer::getVersion() const { return m_version; }
const string &AesContainer::getData() const { return m_data; }
unsigned long AesContainer::getInput_length() const { return m_input_length; }
unsigned long AesContainer::getOutput_length() const { return m_output_length; }
unsigned int AesContainer::getPaddingLength() const { return m_paddingLength; }
const unsigned char *AesContainer::getKey() const { return m_key; }
const mbedtls_aes_context &AesContainer::getAES() const { return m_aes; }
const unsigned char *AesContainer::getIV() const { return m_iv; }
const unsigned char *AesContainer::getBlock_input() const { return m_block_input; }
const unsigned char *AesContainer::getBlock_output() const { return m_block_output; }

bool AesContainer::isValidKey() const {
	//todo
	return true;
}


//Setters
void AesContainer::clear(){
	m_version = 128;
}


//Other methods
//todo: change this for true random generator, iv must be generated by true random generator
void AesContainer::initializeIV(){
	std::string iv = "abcdefghijklmno"; 	//my pseudorandom vector
	std::copy(iv.begin(), iv.end(), m_iv);	//Add here initialiazer vector created by random numbers generator
}


//Other methods
std::string AesContainer::encrypt() {

	std::string buffer;
	std::string outputBuffer;

	for(unsigned int i = 0; i < m_output_length / (m_version / 8); ++i){
		prepareBlock(i);
		if(mbedtls_aes_crypt_cbc( &m_aes, MBEDTLS_AES_ENCRYPT, 128, m_iv, m_block_input, m_block_output ) == MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH){
			std::cout << "AesContainer::encrypt::mbettls_aes_crypt_cbc: error after calling mbedTLS ecnryption function" << std::endl;
		}
		outputBuffer = (char*) m_block_output; //be careful: conversion signed -> unsigned char !
		buffer.append(outputBuffer);
	}
	return buffer;
}

std::string AesContainer::decrypt() {

	std::string buffer;
	std::string outputBuffer;

	for(unsigned int i = 0; i < m_output_length / (m_version / 8); ++i){
		prepareBlock(i);
		if(mbedtls_aes_crypt_cbc( &m_aes, MBEDTLS_AES_DECRYPT, 128, m_iv, m_block_input, m_block_output ) == MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH){
			std::cout << "AesContainer::decrypt::mbettls_aes_crypt_cbc: error after calling mbedTLS ecnryption function" << std::endl;
		}
		outputBuffer = (char*) m_block_output; //be careful: conversion signed -> unsigned char !
		buffer.append(outputBuffer);
	}
	return buffer;
}

int AesContainer::prepareBlock(unsigned int iterator){
	std::string buffer = m_data.substr(iterator*m_version, iterator*m_version + m_version);
	std::strcpy((char*)m_block_output, buffer.c_str()); //be careful: conversion signed -> unsigned char !
	//std::copy(buffer.begin(), buffer.end(), m_block_output);
	return 0;
}

/*
//pre-generated random key
unsigned char key[32] = { 'o', 'a', 'b', 's', 'w', 'o', 'e', 'd', 'v', 'h', 'q', 'm', 'z', 'g', 'a', 'u','y','q','g','l','5','`','1','Z','q','H','7','F','f','b','n',' '};
unsigned char iv[16] = { 14, 31, 60, 126, 81, 12, 36, 102, 57, 9, 42, 51, 111, 4, 3, 25 };
*/